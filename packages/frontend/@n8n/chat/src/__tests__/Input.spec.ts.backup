import type { VueWrapper } from '@vue/test-utils';
import { mount } from '@vue/test-utils';
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

import Input from '../components/Input.vue';

vi.mock('@vueuse/core', () => ({
	useFileDialog: vi.fn(() => ({
		open: vi.fn(),
		reset: vi.fn(),
		onChange: vi.fn(),
	})),
}));

vi.mock('uuid', () => ({
	v4: vi.fn(() => 'mock-uuid-123'),
}));

vi.mock('virtual:icons/mdi/paperclip', () => ({
	default: { name: 'IconPaperclip' },
}));

vi.mock('virtual:icons/mdi/send', () => ({
	default: { name: 'IconSend' },
}));

vi.mock('@n8n/chat/composables', () => ({
	useI18n: vi.fn(),
	useChat: vi.fn(),
	useOptions: vi.fn(),
}));

vi.mock('@n8n/chat/event-buses', () => ({
	chatEventBus: {
		on: vi.fn(),
		off: vi.fn(),
	},
}));

vi.mock('./ChatFile.vue', () => ({
	default: { name: 'ChatFile' },
}));

describe('ChatInput', () => {
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	let wrapper: VueWrapper<any>;
	let chatStoreMock: any;
	let optionsMock: any;
	let mockUseFileDialogReturn: any;
	let mockWebSocket: any;

	beforeEach(() => {
		chatStoreMock = {
			waitingForResponse: { value: false },
			currentSessionId: { value: 'session-123' },
			messages: { value: [] },
			sendMessage: vi.fn().mockResolvedValue({ executionId: 'exec-123' }),
			ws: null,
		};

		optionsMock = {
			options: {
				disabled: { value: false },
				allowFileUploads: { value: true },
				allowedFilesMimeTypes: { value: 'image/*,text/*' },
				webhookUrl: 'https://example.com/webhook',
			},
		};

		mockUseFileDialogReturn = {
			open: vi.fn(),
			reset: vi.fn(),
			onChange: vi.fn(),
		};

		mockWebSocket = {
			send: vi.fn(),
			close: vi.fn(),
			onmessage: null,
			onclose: null,
		};

		// Set up mocks
		const { useI18n, useChat, useOptions } = await import('@n8n/chat/composables');
		vi.mocked(useI18n).mockReturnValue({
			t: (key: string) => key,
		});
		vi.mocked(useChat).mockReturnValue(chatStoreMock);
		vi.mocked(useOptions).mockReturnValue(optionsMock);

		// @ts-expect-error - mock WebSocket
		global.WebSocket = vi.fn().mockImplementation(() => mockWebSocket);

		vi.mocked(require('@vueuse/core').useFileDialog).mockReturnValue(mockUseFileDialogReturn);

		// Mock ResizeObserver
		global.ResizeObserver = vi.fn().mockImplementation(() => ({
			observe: vi.fn(),
			disconnect: vi.fn(),
		}));

		// Mock FileReader
		global.FileReader = vi.fn().mockImplementation(() => ({
			readAsDataURL: vi.fn(),
			onload: null,
			onerror: null,
			result: 'data:text/plain;base64,dGVzdA==',
		}));
	});

	afterEach(() => {
		if (wrapper) {
			wrapper.unmount();
		}
		vi.clearAllMocks();
	});

	it('renders the component with default props', () => {
		wrapper = mount(Input);

		expect(wrapper.find('textarea').exists()).toBe(true);
		expect(wrapper.find('[data-test-id="chat-input"]').exists()).toBe(true);
		expect(wrapper.find('.chat-input-send-button').exists()).toBe(true);
	});

	it('applies custom placeholder', () => {
		wrapper = mount(Input, {
			props: {
				placeholder: 'customPlaceholder',
			},
		});

		const textarea = wrapper.find('textarea');
		expect(textarea.attributes('placeholder')).toBe('customPlaceholder');
	});

	it('updates input value when typing', async () => {
		const textarea = wrapper.find('textarea');

		await textarea.setValue('Hello world');

		expect(wrapper.vm.input).toBe('Hello world');
	});

	it('does not submit on Shift+Enter', async () => {
		const textarea = wrapper.find('textarea');
		const onSubmitSpy = vi.spyOn(wrapper.vm, 'onSubmit');

		await textarea.setValue('Test message');
		await textarea.trigger('keydown.enter', { shiftKey: true });

		expect(onSubmitSpy).not.toHaveBeenCalled();
	});

	it('sets up WebSocket connection with execution ID', () => {
		const executionId = 'exec-123';

		wrapper.vm.setupWebsocketConnection(executionId);

		expect(global.WebSocket).toHaveBeenCalledWith(expect.stringContaining('sessionId=session-123'));
		expect(global.WebSocket).toHaveBeenCalledWith(expect.stringContaining('executionId=exec-123'));
	});

	it('handles WebSocket messages correctly', async () => {
		const mockWs = {
			send: vi.fn(),
			onmessage: null,
			onclose: null,
		};
		wrapper.vm.chatStore.ws = mockWs;
		wrapper.vm.waitingForChatResponse = true;

		await wrapper.vm.respondToChatNode(mockWs, 'Test message');

		expect(mockWs.send).toHaveBeenCalledWith(expect.stringContaining('"chatInput":"Test message"'));
	});

	it('handles empty file list gracefully', () => {
		wrapper.vm.files = null;

		expect(() => wrapper.vm.attachFiles()).not.toThrow();
		expect(wrapper.vm.attachFiles()).toEqual([]);
	});

	it('prevents submit when disabled', async () => {
		const submitButton = wrapper.find('.chat-input-send-button');

		await submitButton.trigger('click');

		expect(wrapper.vm.isSubmitting).toBe(false);
	});

	describe('File handling', () => {
		beforeEach(() => {
			wrapper = mount(Input);
		});

		it('shows file upload button when allowed', () => {
			expect(wrapper.find('[data-test-id="chat-attach-file-button"]').exists()).toBe(true);
		});

		it('hides file upload button when not allowed', async () => {
			optionsMock.options.allowFileUploads.value = false;
			await wrapper.vm.$nextTick();
			
			expect(wrapper.find('[data-test-id="chat-attach-file-button"]').exists()).toBe(false);
		});

		it('opens file dialog when file button clicked', async () => {
			const fileButton = wrapper.find('[data-test-id="chat-attach-file-button"]');
			await fileButton.trigger('click');

			expect(mockUseFileDialogReturn.open).toHaveBeenCalledWith({
				accept: 'image/*,text/*'
			});
		});

		it('handles file removal correctly', async () => {
			const mockFile = new File(['content'], 'test.txt', { type: 'text/plain' });
			const mockDataTransfer = {
				files: [mockFile],
				items: {
					add: vi.fn(),
				}
			};
			
			wrapper.vm.files = mockDataTransfer.files;
			wrapper.vm.onFileRemove(mockFile);

			expect(mockUseFileDialogReturn.reset).toHaveBeenCalled();
		});

		it('processes files correctly', async () => {
			const mockFile = new File(['content'], 'test.txt', { type: 'text/plain' });
			const mockFileReader = {
				readAsDataURL: vi.fn(),
				onload: null,
				onerror: null,
				result: 'data:text/plain;base64,dGVzdA=='
			};

			global.FileReader = vi.fn().mockImplementation(() => mockFileReader);

			const promise = wrapper.vm.processFiles([mockFile]);
			
			// Simulate successful file read
			if (mockFileReader.onload) {
				mockFileReader.onload();
			}

			const result = await promise;
			expect(result).toEqual([{
				name: 'test.txt',
				type: 'text/plain',
				data: 'data:text/plain;base64,dGVzdA=='
			}]);
		});

		it('handles file processing errors', async () => {
			const mockFile = new File(['content'], 'test.txt', { type: 'text/plain' });
			const mockFileReader = {
				readAsDataURL: vi.fn(),
				onload: null,
				onerror: null,
				error: { message: 'Read error' }
			};

			global.FileReader = vi.fn().mockImplementation(() => mockFileReader);

			const promise = wrapper.vm.processFiles([mockFile]);
			
			// Simulate file read error
			if (mockFileReader.onerror) {
				mockFileReader.onerror();
			}

			await expect(promise).rejects.toThrow('Error reading file: Read error');
		});
	});

	describe('WebSocket functionality', () => {
		beforeEach(() => {
			wrapper = mount(Input);
		});

		it('sets up WebSocket connection correctly', () => {
			const executionId = 'exec-123';
			wrapper.vm.setupWebsocketConnection(executionId);

			expect(global.WebSocket).toHaveBeenCalledWith(
				expect.stringContaining('sessionId=session-123')
			);
		});

		it('handles WebSocket heartbeat messages', () => {
			wrapper.vm.setupWebsocketConnection('exec-123');
			chatStoreMock.ws = mockWebSocket;

			// Simulate heartbeat message
			if (mockWebSocket.onmessage) {
				mockWebSocket.onmessage({ data: 'n8n|heartbeat' });
			}

			expect(mockWebSocket.send).toHaveBeenCalledWith('n8n|heartbeat-ack');
		});

		it('handles WebSocket continue message', () => {
			wrapper.vm.setupWebsocketConnection('exec-123');
			chatStoreMock.ws = mockWebSocket;
			wrapper.vm.waitingForChatResponse = true;

			// Simulate continue message
			if (mockWebSocket.onmessage) {
				mockWebSocket.onmessage({ data: 'n8n|continue' });
			}

			expect(wrapper.vm.waitingForChatResponse).toBe(false);
			expect(chatStoreMock.waitingForResponse.value).toBe(true);
		});

		it('handles regular WebSocket messages', () => {
			wrapper.vm.setupWebsocketConnection('exec-123');
			chatStoreMock.ws = mockWebSocket;

			// Simulate regular message
			if (mockWebSocket.onmessage) {
				mockWebSocket.onmessage({ data: 'Bot response message' });
			}

			expect(chatStoreMock.messages.value).toHaveLength(1);
			expect(chatStoreMock.messages.value[0]).toEqual({
				id: 'mock-uuid-123',
				text: 'Bot response message',
				sender: 'bot',
			});
		});

		it('handles WebSocket close event', () => {
			wrapper.vm.setupWebsocketConnection('exec-123');
			chatStoreMock.ws = mockWebSocket;
			wrapper.vm.waitingForChatResponse = true;

			// Simulate WebSocket close
			if (mockWebSocket.onclose) {
				mockWebSocket.onclose();
			}

			expect(chatStoreMock.ws).toBe(null);
			expect(wrapper.vm.waitingForChatResponse).toBe(false);
		});

		it('responds to chat node correctly', async () => {
			const messageText = 'User message';
			const mockFile = new File(['content'], 'test.txt', { type: 'text/plain' });
			
			wrapper.vm.files = [mockFile];
			await wrapper.vm.respondToChatNode(mockWebSocket, messageText);

			expect(chatStoreMock.messages.value).toHaveLength(1);
			expect(mockWebSocket.send).toHaveBeenCalledWith(
				expect.stringContaining('"chatInput":"User message"')
			);
		});

		it('handles WebSocket setup errors gracefully', () => {
			const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
			global.WebSocket = vi.fn().mockImplementation(() => {
				throw new Error('WebSocket connection failed');
			});

			expect(() => wrapper.vm.setupWebsocketConnection('exec-123')).not.toThrow();
			expect(consoleSpy).toHaveBeenCalledWith(
				'Error setting up websocket connection',
				expect.any(Error)
			);

			consoleSpy.mockRestore();
		});
	});

	describe('Event handling', () => {
		beforeEach(() => {
			wrapper = mount(Input);
		});

		it('handles arrow key navigation', async () => {
			const textarea = wrapper.find('textarea');
			await textarea.setValue('Test message');

			await textarea.trigger('keydown', { key: 'ArrowUp' });

			expect(wrapper.emitted('arrowKeyDown')).toEqual([[{
				key: 'ArrowUp',
				currentInputValue: 'Test message'
			}]]);
		});

		it('handles arrow down navigation', async () => {
			const textarea = wrapper.find('textarea');
			await textarea.setValue('Another message');

			await textarea.trigger('keydown', { key: 'ArrowDown' });

			expect(wrapper.emitted('arrowKeyDown')).toEqual([[{
				key: 'ArrowDown',
				currentInputValue: 'Another message'
			}]]);
		});

		it('adjusts textarea height on input', async () => {
			const textarea = wrapper.find('textarea');
			const adjustSpy = vi.spyOn(wrapper.vm, 'adjustTextAreaHeight');

			await textarea.trigger('input');

			expect(adjustSpy).toHaveBeenCalled();
		});

		it('adjusts textarea height on focus', async () => {
			const textarea = wrapper.find('textarea');
			const adjustSpy = vi.spyOn(wrapper.vm, 'adjustTextAreaHeight');

			await textarea.trigger('focus');

			expect(adjustSpy).toHaveBeenCalled();
		});

		it('adjusts textarea height correctly', () => {
			const mockTextarea = {
				style: { height: '' },
				scrollHeight: 100
			};
			wrapper.vm.chatTextArea = mockTextarea;

			wrapper.vm.adjustTextAreaHeight();

			expect(mockTextarea.style.height).toBe('100px');
		});

		it('limits textarea height to maximum', () => {
			const mockTextarea = {
				style: { height: '' },
				scrollHeight: 600 // Exceeds 480px limit
			};
			wrapper.vm.chatTextArea = mockTextarea;

			wrapper.vm.adjustTextAreaHeight();

			expect(mockTextarea.style.height).toBe('480px');
		});
	});

	describe('Chat event bus integration', () => {
		beforeEach(() => {
			wrapper = mount(Input);
		});

		it('sets up event listeners on mount', () => {
			const mockEventBus = require('@n8n/chat/event-buses').chatEventBus;
			
			expect(mockEventBus.on).toHaveBeenCalledWith('focusInput', expect.any(Function));
			expect(mockEventBus.on).toHaveBeenCalledWith('blurInput', expect.any(Function));
			expect(mockEventBus.on).toHaveBeenCalledWith('setInputValue', expect.any(Function));
		});

		it('focuses input correctly', () => {
			const mockTextarea = { focus: vi.fn() };
			wrapper.vm.chatTextArea = mockTextarea;

			wrapper.vm.focusChatInput();

			expect(mockTextarea.focus).toHaveBeenCalled();
		});

		it('blurs input correctly', () => {
			const mockTextarea = { blur: vi.fn() };
			wrapper.vm.chatTextArea = mockTextarea;

			wrapper.vm.blurChatInput();

			expect(mockTextarea.blur).toHaveBeenCalled();
		});

		it('sets input value and focuses', () => {
			const mockTextarea = { focus: vi.fn() };
			wrapper.vm.chatTextArea = mockTextarea;

			wrapper.vm.setInputValue('New value');

			expect(wrapper.vm.input).toBe('New value');
			expect(mockTextarea.focus).toHaveBeenCalled();
		});
	});

	describe('Submit behavior', () => {
		beforeEach(() => {
			wrapper = mount(Input);
		});

		it('submits message successfully', async () => {
			await wrapper.find('textarea').setValue('Test message');
			
			await wrapper.vm.onSubmit(new MouseEvent('click'));

			expect(chatStoreMock.sendMessage).toHaveBeenCalledWith('Test message', []);
			expect(wrapper.vm.input).toBe('');
			expect(wrapper.vm.isSubmitting).toBe(false);
		});

		it('does not submit when input is empty', async () => {
			const event = new MouseEvent('click');
			const preventDefaultSpy = vi.spyOn(event, 'preventDefault');

			await wrapper.vm.onSubmit(event);

			expect(preventDefaultSpy).toHaveBeenCalled();
			expect(chatStoreMock.sendMessage).not.toHaveBeenCalled();
		});

		it('does not submit when waiting for response', async () => {
			chatStoreMock.waitingForResponse.value = true;
			await wrapper.find('textarea').setValue('Test message');

			await wrapper.vm.onSubmit(new MouseEvent('click'));

			expect(chatStoreMock.sendMessage).not.toHaveBeenCalled();
		});

		it('does not submit when disabled', async () => {
			optionsMock.options.disabled.value = true;
			await wrapper.find('textarea').setValue('Test message');

			await wrapper.vm.onSubmit(new MouseEvent('click'));

			expect(chatStoreMock.sendMessage).not.toHaveBeenCalled();
		});

		it('handles shift+enter correctly', async () => {
			const textarea = wrapper.find('textarea');
			await textarea.setValue('Test message');

			const event = new KeyboardEvent('keydown', { key: 'Enter', shiftKey: true });
			await wrapper.vm.onSubmitKeydown(event);

			expect(chatStoreMock.sendMessage).not.toHaveBeenCalled();
		});

		it('handles composing input correctly', async () => {
			const textarea = wrapper.find('textarea');
			await textarea.setValue('Test message');

			// @ts-expect-error - isComposing is not in the type but exists in browsers
			const event = new KeyboardEvent('keydown', { key: 'Enter', isComposing: true });
			await wrapper.vm.onSubmitKeydown(event);

			expect(chatStoreMock.sendMessage).not.toHaveBeenCalled();
		});
	});

	describe('Component state', () => {
		beforeEach(() => {
			wrapper = mount(Input);
		});

		it('computes submit disabled state correctly', () => {
			// Empty input should disable submit
			wrapper.vm.input = '';
			expect(wrapper.vm.isSubmitDisabled).toBe(true);

			// Non-empty input should enable submit
			wrapper.vm.input = 'test';
			expect(wrapper.vm.isSubmitDisabled).toBe(false);

			// Waiting for response should disable submit
			chatStoreMock.waitingForResponse.value = true;
			expect(wrapper.vm.isSubmitDisabled).toBe(true);
		});

		it('computes input disabled state correctly', () => {
			expect(wrapper.vm.isInputDisabled).toBe(false);

			optionsMock.options.disabled.value = true;
			expect(wrapper.vm.isInputDisabled).toBe(true);
		});

		it('computes file upload disabled state correctly', () => {
			expect(wrapper.vm.isFileUploadDisabled).toBe(false);

			chatStoreMock.waitingForResponse.value = true;
			expect(wrapper.vm.isFileUploadDisabled).toBe(true);

			optionsMock.options.disabled.value = true;
			expect(wrapper.vm.isFileUploadDisabled).toBe(false); // disabled overrides waiting
		});

		it('computes style variables correctly', () => {
			expect(wrapper.vm.styleVars).toEqual({
				'--controls-count': 2 // file upload + send button
			});

			optionsMock.options.allowFileUploads.value = false;
			expect(wrapper.vm.styleVars).toEqual({
				'--controls-count': 1 // send button only
			});
		});
	});

	describe('Cleanup', () => {
		it('cleans up event listeners and observers on unmount', () => {
			wrapper = mount(Input);
			const mockEventBus = require('@n8n/chat/event-buses').chatEventBus;
			const mockResizeObserver = {
				observe: vi.fn(),
				disconnect: vi.fn(),
			};
			wrapper.vm.resizeObserver = mockResizeObserver;

			wrapper.unmount();

			expect(mockEventBus.off).toHaveBeenCalledWith('focusInput', expect.any(Function));
			expect(mockEventBus.off).toHaveBeenCalledWith('blurInput', expect.any(Function));
			expect(mockEventBus.off).toHaveBeenCalledWith('setInputValue', expect.any(Function));
			expect(mockResizeObserver.disconnect).toHaveBeenCalled();
		});
	});
});
